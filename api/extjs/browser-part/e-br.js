// jscs:ignore
(function setEBr() {
  'use strict';

  console.log('TIA: setEBr');

  window.tiaEJ = {

    ejIdle: false, //

    debugLocale: false,

    setDebugLocaleMode: function setDebugLocaleMode(newMode) {
      this.debugLocale = newMode;
    },

    locale: null,
    invertedLocaleFirstKey: null, // only first key is keeped for non unique values.
    invertedLocaleAllKeys: null, // all keys are keeped for non unique values

    setLocale: function setLocale(newLocale) {
      this.locale = newLocale;
      var invertedObjs = tia.cU.invertMapObj(newLocale);

      this.invertedLocaleFirstKey = invertedObjs.invertedMapFirstKey;
      this.invertedLocaleAllKeys = invertedObjs.invertedMapAllKeys;

      return {
        locale: this.locale,
        invertedLocaleFirstKey: invertedObjs.invertedMapFirstKey,
        invertedLocaleAllKeys: invertedObjs.invertedMapAllKeys,
      };
    },

    getLocaleValue: function getLocaleValue(key) {
      return this.locale[key];
    },

    getFirstLocaleKey: function getFirstLocaleKey(value) {
      return this.invertedLocaleFirstKey[value];
    },

    getAllLocaleKeys: function getAllLocaleKeys(value) {
      return this.invertedLocaleAllKeys[value];
    },

    /**
     * Maps static fake id or itemId to real [autogenerated] id or itemId.
     */
    idMap: {
      fakeToReal: new Map(),
      realToFake: new Map(),
      add: function add(fakeId, realId) {
        if (directMap.get(fakeId)) {
          throw new Error(fakeId + 'is already in map.');
        }
        this.fakeToReal.set(fakeId, realId);
        this.realToFake.set(realId, fakeId);
      },
      getFakeId: function getFakeId(realId) {
        return this.realToFake(realId);
      },
      getRealId: function getRealId(fakeId) {
        return this.fakeToReal(fakeId);
      },
      remove: function remove(fakeId) {
        var realId = this.fakeToReal.get(fakeId);
        if (!realId) {
          throw new Error(fakeId + 'is not in map.');
        }
        this.fakeToReal.delete(fakeId);
        this.realToFake.delete(realId);
      },
      removeAll: function removeAll() {
        this.fakeToReal.clear();
        this.realToFake.clear();
      },
    },

    // It if returns true there is not a bad chance that ExtJs application is ready to use.
    // Deprecated.
    isExtJsReady: function isExtJsReady() {
      return !(typeof Ext === 'undefined' || !Ext.isReady || typeof Ext.onReady === 'undefined' ||
        typeof Ext.Ajax === 'undefined' || typeof Ext.Ajax.on === 'undefined');
    },

    isExtJsIdle: function isExtJsIdle() {
      return this.isExtJsReady() && !this.isThereActiveAjaxCalls() && this.ejIdle && tia.isIdle();
    },

    resetExtJsIdle: function resetExtJsIdle() {
      function idleHandler() {
        window.tiaEJ.ejIdle = true;
      }

      Ext.on({ idle: { fn: idleHandler, scope: this, single: true } });
      this.ejIdle = false;
    },

    ajaxFailuresArr: [],

    // hasAjaxFailures: function() {
    //	return this.ajaxFailuresArr.length > 0;
    // },

    cleanAjaxFailures: function cleanAjaxFailures() {
      this.ajaxFailuresArr = [];
    },

    getAjaxFailures: function getAjaxFailures() {
      var tmp = this.ajaxFailuresArr;
      this.cleanAjaxFailures();
      return tmp;
    },

    isThereActiveAjaxCalls: function isThereActiveAjaxCalls() {
      return Ext.Ajax.isLoading();
    },

    // If field is omited - all data will be fetched.
    getStoreData: function getStoreData(storeId, field) {
      var arr = Ext.StoreManager.get(storeId).getRange();
      var res = arr.map(function (elem) {
        return elem[field];
      });
      return res;
    },

    /**
     * First localization key by text.
     * @param {String} text - text to be searched in localization.
     * @return {String} - found key or empty string.
     */
    getFirstLocKeyByText: function getFirstLocKeyByText(text) {
      var candidate = this.getFirstLocaleKey(text);
      return typeof candidate === 'undefined' ? '' : candidate;
    },

    /**
     * All localization keys by text.
     * @param {String} text - text to be searched in localization.
     * @return {String} - found keys separated by comma or empty string.
     */
    getLocKeysByText: function getLocKeysByText(text) {
      var candidates = this.getAllLocaleKeys(text);
      return typeof candidates === 'undefined' ? '' : candidates;
    },

    getTextByLocKey: function getTextByLocKey(key) {
      var res = this.getLocaleValue(key);
      if (typeof res === 'undefined') {
        throw new Error('No such key in locale: ' + key);
      }
      return res;
    },

    convertTextToLocKeys: function convertTextToLocKeys(text) {
      var locKeys = this.getLocKeysByText(text);
      var result = 'l"' + locKeys + '"';
      if (!locKeys || this.debugLocale) {
        result += '("' + text + '")';
      }
      return result;
    },

    convertTextToFirstLocKey: function convertTextToFirstLocKey(text) {
      var locKey = this.getFirstLocKeyByText(text);
      var result = 'l"' + locKey + '"';
      if (!locKey || this.debugLocale) {
        result += '("' + text + '")';
      }
      return result;
    },

    funcResultToLocale: function funcResultToLocale(destArr, cmp, funcName, alias) {
      if (cmp[funcName]) {
        var val = cmp[funcName]();
        destArr.push(alias + ': ' + this.convertTextToFirstLocKey(val));
      }
    },

    propToLocale: function propToLocale(destArr, cmp, propName) {
      var val = cmp[propName];
      if (typeof val !== 'undefined') {
        destArr.push(propName + ': ' + this.convertTextToFirstLocKey(val));
      }
    },

    /**
     * Replaces 'l"locale_key"' by '"text"', where text is the locale value for the given key.
     * @param {String} str - input string.
     * @return {String} - string with replaced text.
     */
    replaceLocKeys: function replaceLocKeys(str) {
      var re = /l"(.*?)"/g;
      return str.replace(re, function (m, key) {
        return '"' + tiaEJ.getLocaleValue(key) + '"';
      });
    },

    /**
     * Replaces '##some_my_fake-id3' by '#<real-temporary-id-from tiaEJ.idHash>'
     * @param str
     * @return {string|Object|void|*}
     */
    replaceFakeIds: function replaceFakeIds(str) {
      var re = /##([A-Za-z0-9_-]+)/g;
      return str.replace(re, function (m, fakeId) {
        return '#' + tiaEJ.idMap.getRealId(fakeId);
      });
    },

    replaceAll: function replaceAll(str) {
      return this.replaceFakeIds(this.replaceLocKeys(str));
    },

    showMsgBox: function showMsgBox(msg, title) {
      var msgBox = Ext.Msg.show({
        title: 'TIA ExtJs exploration: ' + title,
        titleAlign: 'center', // Seems like does not work.
        message: msg.replace(/\n/g, '<br>'),
        width: 1200,
        minWidth: 1200,
        minHeight: 1200,
        modal: false,
        scrollable: true,
      });
    },

    getMainView: function getMainView() {
      return Ext.Component.fromElement(Ext.getBody());
    },

    getAppName: function getAppName() {
      return Ext.app.Application.instance.getName();
    },

    getApp: function getApp() {
      return window[this.getAppName()];
    },

  };

  var onAjaxError = function onAjaxError(conn, response, options, eOpts) {
    tiaEJ.ajaxFailuresArr.push('Ajax Exception: response.status: ' + response.status);
  };

  Ext.onReady(function () {
    Ext.Ajax.on({
      requestexception: onAjaxError,
    });
  });
})();
